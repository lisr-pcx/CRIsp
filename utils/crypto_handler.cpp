#include "crypto_handler.h"
#include <QLoggingCategory>
#include <QFile>
#include <QTextStream>

CryptoHandler::CryptoHandler()
{
    // nothing
}

qint8 CryptoHandler::encrypt_file(QString const targetFilePath,
                                  QString const keyFilePath,
                                  QString const ivFilePath)
{
    return CryptoHandler::check_and_run(targetFilePath,
                                        keyFilePath,
                                        ivFilePath,
                                        CryptoHandler::ENCRYPT);
}

qint8 CryptoHandler::decrypt_file(QString const targetFilePath,
                                  QString const keyFilePath,
                                  QString const ivFilePath)
{
    return CryptoHandler::check_and_run(targetFilePath,
                                        keyFilePath,
                                        ivFilePath,
                                        CryptoHandler::DECRYPT);
}

QByteArray CryptoHandler::read_pem_file(QString const filepath)
{
    // Example of valid PEM format (32bytes in base64):
    // -----BEGIN PRIVATE KEY-----
    // e8SEw52yBLa0hV6NrD8Of+8qGE6/CTrkyOZ7tvgmuwU=
    // -----END PRIVATE KEY-----

    QFile pemFile(filepath);
    QByteArray data;
    bool is_valid = false;
    if (pemFile.open(QFile::ReadOnly))
    {
        QTextStream in(&pemFile);
        QString line = in.readLine();
        if (line.compare("-----BEGIN PRIVATE KEY-----") == 0)
        {
            while (!in.atEnd())
            {
                line = in.readLine();
                if (line.compare("-----END PRIVATE KEY-----") == 0)
                {
                    is_valid = true;
                    break;
                }
                else
                {
                    data.push_back(QByteArray::fromBase64(line.toUtf8()));
                }
            }
        }
    }
    pemFile.close();
    // when file is not valid, reset and return nothing
    if (!is_valid)
    {
        data.clear();
    }
    return data;
}

void CryptoHandler::write_pem_file(QString const filepath, QString& keyBase64)
{
    QFile pemFile(filepath);
    if (pemFile.open(QFile::WriteOnly))
    {
        QTextStream out(&pemFile);
        out << "-----BEGIN PRIVATE KEY-----\n";
        out << keyBase64 << "\n";
        out << "-----END PRIVATE KEY-----\n";
    }
    pemFile.close();
}

QByteArray CryptoHandler::read_binary_file(QString const filepath)
{
    QFile binaryFile(filepath);
    QByteArray data;
    if (binaryFile.open(QFile::ReadOnly))
    {
        data = binaryFile.readAll();
    }
    binaryFile.close();
    return data;
}

void CryptoHandler::write_binary_file(QString const filepath, QByteArray& data)
{
    QFile binaryFile(filepath);
    if (binaryFile.open(QFile::WriteOnly))
    {
        binaryFile.write(data);
    }
    binaryFile.close();
}

qint8 CryptoHandler::check_and_run(QString targetFilePath,
                                   QString passphrFilePath,
                                   QString rootpswFilePath,
                                   qint64 mode)
{
    qint8 retStatus = -1;
    QByteArray passphr = CryptoHandler::read_pem_file(passphrFilePath);
    QByteArray rootpsw = CryptoHandler::read_pem_file(rootpswFilePath);
    QByteArray target = CryptoHandler::read_binary_file(targetFilePath);

    // Create KEY
    QByteArray key = CryptoHandler::create_key(rootpsw, passphr);

    // Create HARD-CODED initialization vector (IV)
    // Generated by OpenSSL
    // $ openssl rand -hex 16
    QByteArray iv = QByteArrayLiteral("\x4c\x9b\x8a\x41\xd3\x77\x29\x7b\xb6\x51\x0b\x06\x4c\xd4\xe3\x16");

    // Check pre-condition
    if ((key.size() == AES256CBC::localKeySize) &&
        (iv.size() == AES256CBC::localIVSize) &&
        (target.size() > 0) )
    {
        // Init
        AES256CBC* cryptoTool = new AES256CBC(key, iv);

        switch(mode)
        {
        case CryptoHandler::ENCRYPT:
            CryptoHandler::apply_PKCS7_padding(target, cryptoTool->localIVSize);
            cryptoTool->encryptData(target);
            // A new file with extensione ".encrypted" is generated after processing.
            // It shall be renamed as desired, to be used in ATOM (or similar tools).
            targetFilePath += ".encrypted";
            CryptoHandler::write_binary_file(targetFilePath, target);
            break;
        case CryptoHandler::DECRYPT:
            cryptoTool->decryptData(target);
            CryptoHandler::remove_PKCS7_padding(target);
            // A new file with extensione ".decrypted" is generated after processing.
            targetFilePath += ".decrypted";
            CryptoHandler::write_binary_file(targetFilePath, target);
            break;
        }
        delete cryptoTool;
        retStatus = 0;
    }
    return retStatus;
}



QByteArray CryptoHandler::create_key(QByteArray first_key,
                                     QByteArray second_key)
{
    QByteArray key;
    if ((first_key.size() > 0) &&
        (second_key.size() > 0) && // can be removed
        (first_key.size() == second_key.size()))
    {
        for (qsizetype i=0; i<first_key.size(); i++)
        {
            key.push_back(first_key[i] ^ second_key[i]);
        }
    }
    return key;
}

void CryptoHandler::apply_PKCS7_padding(QByteArray& data, quint8 blockSize)
{
    quint8 add_n_bytes = blockSize - (data.size() % blockSize);
    for (quint8 n=add_n_bytes; n>0; n--)
    {
        data.push_back(add_n_bytes);
    }
}

void CryptoHandler::remove_PKCS7_padding(QByteArray& data)
{
    if (data.size()>0)
    {
        // check padding, remove bytes only when valid
        quint8 remove_n_bytes = data.back();
        if (std::count(data.end() - remove_n_bytes, data.end(), remove_n_bytes) == remove_n_bytes)
        {
            data.chop(remove_n_bytes);
        }
    }
}
